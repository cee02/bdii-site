è preciso alterar a tabela armazem e retirar a data de entrada e saida
Alterar a tabela componeneteArmazem e adicionar data de entra e saida

CREATE VIEW componente_saida_stock_recente AS
SELECT
    C.nome AS nome_componente,
    C.quantidade AS quantidade_componente,
    A.nome AS nome_armazem,
    CA.data_saida
FROM
    ComponenteArmazem CA
JOIN Componentes C ON CA.componenteID = C.ID
JOIN Armazem A ON CA.id_armazem = A.ID_armazem
WHERE
    CA.data_saida IS NOT NULL
ORDER BY
    CA.data_saida DESC
LIMIT 10;

CREATE VIEW componente_entrada_stock_recente AS
SELECT
    C.nome AS nome_componente,
    C.quantidade AS quantidade_componente,
    A.nome AS nome_armazem,
    CA.data_entrada
FROM
    ComponenteArmazem CA
JOIN Componentes C ON CA.componenteID = C.ID
JOIN Armazem A ON CA.id_armazem = A.ID_armazem
WHERE
    CA.data_saida IS NOT NULL
ORDER BY
    CA.data_saida DESC
LIMIT 10;


//esta view não estava bem era só para conseguir abrir a pagina dashboard
//usar esta para substituir a view anterior
CREATE VIEW equipamento_entrada_stock_recente AS
SELECT
    E.tipo AS tipo_equipamento,
    E.descricao AS descricao_equipamento,
    A.nome AS nome_armazem,
    EA.data_entrada
FROM
    EquipamentoArmazem EA
JOIN equipamento E ON EA.equipamentoID = E.id_equipamento
JOIN Armazem A ON EA.id_armazem = A.ID_armazem
WHERE
    EA.data_entrada IS NOT NULL
ORDER BY
    EA.data_entrada DESC
LIMIT 10;



INSERT INTO ComponenteArmazem (componenteID, id_armazem, data_entrada, data_saida)
VALUES
    (6, 1, '2024-01-01', '2024-01-05'), 
    (7, 1, '2024-01-02', '2024-01-06'), 
    (8, 1, '2024-01-04', '2024-01-08'), 
    (9, 1, '2024-01-05', '2024-01-09'), 
    (10, 1, '2024-01-05', '2024-01-09'), 
    (11, 1, '2024-01-06', '2024-01-10'),
	(12, 1, '2024-01-04', '2024-01-08'), 
    (13, 1, '2024-01-05', '2024-01-09'), 
    (14, 1, '2024-01-05', '2024-01-09'), 
    (15, 1, '2024-01-06', '2024-01-10'),
	(16, 1, '2024-01-04', '2024-01-08'), 
    (17, 1, '2024-01-05', '2024-01-09'), 
    (18, 1, '2024-01-04', '2024-01-08'), 
    (19, 1, '2024-01-05', '2024-01-09'), 
    (20, 1, '2024-01-06', '2024-01-10');

Criar esta tabela no PGAdmin

CREATE TABLE EquipamentoArmazem (
    equipamentoID INT,
    id_armazem INT,
    data_entrada DATE,
    data_saida DATE,
    FOREIGN KEY (equipamentoID) REFERENCES equipamento(id_equipamento),
    FOREIGN KEY (id_armazem) REFERENCES Armazem(ID_armazem)
);


INSERT INTO EquipamentoArmazem (equipamentoID, id_armazem, data_entrada, data_saida)
VALUES
    (1, 2, '2024-01-01', '2024-01-05'), 
    (2, 2, '2024-01-02', '2024-01-06'), 
    (3, 2, '2024-01-04', '2024-01-08'), 
    (4, 2, '2024-01-05', '2024-01-09'), 
    (5, 2, '2024-01-05', '2024-01-09');


Insert INTO tipooperacao (id, descricao)
Values
(1, 'Montagem de board'),
(2, 'Montagem de ram'),
(3, 'Montagem de GPU'),
(4, 'Montagem Completa'),
(5, 'Instalação de Periféricos'),
(6, 'Embalagem');


Insert Into maoobra (id, tipo, custo)
Values
(1, 'Operador de 1a', 40.50),
(2, 'Operador de 2a',  35.50),
(3, 'Embalador', 25.50),
(4, 'Técnico de Montagem', 59.50),
(5, 'Técnico de Manutenção', 36.50);

CREATE VIEW vw_tipo_operacao AS
SELECT * FROM tipooperacao;

CREATE VIEW vw_mao_obra AS
SELECT * FROM maoobra;

Corram isto no PGADMIN
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO aluno3_a
    REVOKE ALL PRIVILEGES ON ALL TABLES IN SCHEMA public FROM aluno3_c;
    GRANT ALL PRIVILEGES ON TABLE public.equipamento TO aluno3_c;   

//Tem de criar esta view se não o dashboard nao funciona
CREATE VIEW equipamento_saida_stock_recente AS
SELECT
    E.tipo AS tipo_equipamento,
    E.descricao AS descricao_equipamento,
    A.nome AS nome_armazem,
    EA.data_saida
FROM
    EquipamentoArmazem EA
JOIN equipamento E ON EA.equipamentoID = E.id_equipamento
JOIN Armazem A ON EA.id_armazem = A.ID_armazem
WHERE
    EA.data_saida IS NOT NULL
ORDER BY
    EA.data_saida DESC
LIMIT 10;


//Modificações DIA 28
//Usar esta table para substituir a que tem no pgadmin (ComponentesFichaProducao)
CREATE TABLE ComponentesFichaProducao (
    Id SERIAL PRIMARY KEY,
    idcomponente INT,
    quantidadeComponente INT,
    id_tipooperacao INT,
    id_maodeobra INT,
    datahorainicio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    datahorafim TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '15 minutes'),
    FOREIGN KEY (id_tipooperacao) REFERENCES tipooperacao(ID),
    FOREIGN KEY (id_maodeobra) REFERENCES maoobra(ID),
    FOREIGN KEY (idcomponente) REFERENCES componentes(ID),
  	UNIQUE (id, idcomponente)
);

//substituir esta função para o ecrâ Produção Equipamentos funcionar
CREATE OR REPLACE FUNCTION insert_componentes_ficha_producao(
    p_idcomponentes INT[],
    p_quantidadeComponente INT,
    p_id_tipooperacao INT,
    p_id_maodeobra INT
)
RETURNS VOID AS
$$
DECLARE
    idcomponente_element INT;
BEGIN
    -- Get the array length
    FOR i IN 1..array_length(p_idcomponentes, 1)
    LOOP
        -- Retrieve the idcomponente at index i
        idcomponente_element := p_idcomponentes[i];

        -- Insert into the table
       INSERT INTO ComponentesFichaProducao (id, idcomponente, quantidadeComponente, id_tipooperacao, id_maodeobra) 
        VALUES (NEXTVAL('componentesfichaproducao_id_seq'), idcomponente_element, p_quantidadeComponente, p_id_tipooperacao, p_id_maodeobra);
    END LOOP;
EXCEPTION
    WHEN others THEN
        -- Raise an exception with the error message
        RAISE EXCEPTION 'Error in insert_componentes_ficha_producao: %', SQLERRM;
END;
$$
LANGUAGE plpgsql;

GRANT USAGE, SELECT ON SEQUENCE componentesfichaproducao_id_seq TO aluno3_a;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO aluno3_a;


--------------- DIA 30/01 ---------------------
Update este trigger:
Foi removida a linha 'data_entrada = CURRENT_DATE'

BEGIN
   
    UPDATE Armazem
    SET quantidade_em_stock = quantidade_em_stock + NEW.quantidade
    WHERE ID_armazem = 1;

    RETURN NEW;
END;

--Tabela modificada adicionada linha quantidade INT,
CREATE TABLE ComponenteArmazem (
    componenteID INT,
    id_armazem INT,
	quantidade INT,
    data_entrada DATE,
    data_saida DATE,
    FOREIGN KEY (componenteID) REFERENCES Componentes(ID),
    FOREIGN KEY (id_armazem) REFERENCES Armazem(ID_armazem)
);


--  Substituir after_insert_componentes() por esta
CREATE OR REPLACE FUNCTION after_insert_componentes()
RETURNS TRIGGER AS $$
DECLARE
    quantidade_componente INT;
BEGIN
    SELECT quantidade INTO quantidade_componente FROM Componentes WHERE ID = NEW.ID;
    INSERT INTO ComponenteArmazem (componenteID, id_armazem, quantidade, data_entrada)
    VALUES (NEW.ID, 1, quantidade_componente, CURRENT_DATE);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_insert_componentes_trigger
AFTER INSERT ON Componentes
FOR EACH ROW
EXECUTE FUNCTION after_insert_componentes();


-- Neste trigger componente_entrada_stock_recente foi retirado a linha "WHERE
    CA.data_saida IS NOT NULL" e modificada 
    a linha  "ORDER BY ca.data_saida DESC" para "ORDER BY ca.data_entrada DESC"
    Também foi adicionada a linha WHERE

CREATE OR REPLACE VIEW componente_entrada_stock_recente
 AS
 SELECT c.nome AS nome_componente,
    c.quantidade AS quantidade_componente,
    a.nome AS nome_armazem,
    ca.data_entrada
   FROM componentearmazem ca
     JOIN componentes c ON ca.componenteid = c.id
     JOIN armazem a ON ca.id_armazem = a.id_armazem
  WHERE ca.data_entrada >= (CURRENT_DATE - '2 days'::interval)
  ORDER BY ca.data_entrada DESC
 LIMIT 10;


--Apagar o trigger update_stock_apos_compra_fornecedor e substituir por esta --
--Armazem sempre a atualizar --
 CREATE OR REPLACE FUNCTION update_armazem_quantidade()
RETURNS TRIGGER AS $$
DECLARE
    total_quantidade INT;
BEGIN
    -- Calculate the total quantity of components in ComponenteArmazem for the specific armazem
    SELECT COALESCE(SUM(quantidade), 0) INTO total_quantidade
    FROM Componentearmazem
    WHERE id_armazem = NEW.id_armazem;

    -- Update the Armazem table with the calculated total quantity
    UPDATE Armazem
    SET quantidade_em_stock = total_quantidade
    WHERE ID_armazem = NEW.id_armazem;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for AFTER INSERT on ComponenteArmazem
CREATE TRIGGER after_insert_componente_armazem
AFTER INSERT OR UPDATE OR DELETE ON Componentearmazem
FOR EACH ROW
EXECUTE FUNCTION update_armazem_quantidade();



GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO aluno3_a;


----DIA 01 Fevereiro ---

--Criar esta table para controlar cada Lista de Produção
CREATE TABLE ProducaoHeader (
    Id SERIAL PRIMARY KEY
);

-- Usar este Alter para alterar a tabela ComponentesFichaProducao(vai adicionar uma row importantissima)
ALTER TABLE ComponentesFichaProducao
ADD COLUMN id_producao_header INT,
ADD CONSTRAINT fk_producao_header
    FOREIGN KEY (id_producao_header)
    REFERENCES ProducaoHeader(Id);

--A tabela dps desses comandos vai ficar assim
CREATE TABLE ComponentesFichaProducao (
    Id SERIAL PRIMARY KEY,
    idcomponente INT,
    quantidadeComponente INT,
    id_tipooperacao INT,
    id_maodeobra INT,
    datahorainicio TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    datahorafim TIMESTAMP DEFAULT (CURRENT_TIMESTAMP + INTERVAL '15 minutes'),
    id_producao_header INT,  -- New field for the foreign key reference to ProducaoHeader
    FOREIGN KEY (id_tipooperacao) REFERENCES tipooperacao(ID),
    FOREIGN KEY (id_maodeobra) REFERENCES maoobra(ID),
    FOREIGN KEY (idcomponente) REFERENCES componentes(ID),
    FOREIGN KEY (id_producao_header) REFERENCES ProducaoHeader(Id),  -- New foreign key
  	UNIQUE (id, idcomponente)
);

-- Modifiquei a função insert_componentes_ficha_producao, Podem apagar a anterior e colocar esta
CREATE OR REPLACE FUNCTION insert_componentes_ficha_producao(
    p_idcomponentes INT[],
    p_quantidadeComponente INT,
    p_id_tipooperacao INT,
    p_id_maodeobra INT,
    p_id_producao_header INT 
)
RETURNS VOID AS
$$
DECLARE
    idcomponente_element INT;
BEGIN
    -- Get the array length
    FOR i IN 1..array_length(p_idcomponentes, 1)
    LOOP
        -- Retrieve the idcomponente at index i
        idcomponente_element := p_idcomponentes[i];

        -- Insert into the ComponentesFichaProducao table
        INSERT INTO ComponentesFichaProducao (id, idcomponente, quantidadeComponente, id_tipooperacao, id_maodeobra, id_producao_header) 
        VALUES (NEXTVAL('componentesfichaproducao_id_seq'), idcomponente_element, p_quantidadeComponente, p_id_tipooperacao, p_id_maodeobra, p_id_producao_header);

        -- Update the ComponenteArmazem table by subtracting 1 from quantidade and updating data_saida
        UPDATE ComponenteArmazem
        SET quantidade = quantidade - 1,
            data_saida = CURRENT_DATE  -- You can adjust this based on your requirement
        WHERE componenteID = idcomponente_element;
    END LOOP;
EXCEPTION
    WHEN others THEN
        -- Raise an exception with the error message
        RAISE EXCEPTION 'Error in insert_componentes_ficha_producao: %', SQLERRM;
END;
$$
LANGUAGE plpgsql;

-- Dar grant outra vez
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO aluno3_a;
GRANT USAGE, SELECT ON SEQUENCE producaoheader_id_seq TO aluno3_a;

-- view para mostrar mes e ano em que houve componentes a entrar ou a sair do componentearmazem
CREATE OR REPLACE VIEW view_meses_anos_componentearmazem AS
SELECT DISTINCT
    EXTRACT(MONTH FROM data_entrada) AS mes,
    EXTRACT(YEAR FROM data_entrada) AS ano
FROM componentearmazem
UNION
SELECT DISTINCT
    EXTRACT(MONTH FROM data_saida) AS mes,
    EXTRACT(YEAR FROM data_saida) AS ano
FROM componentearmazem;

-- é preciso instalar isto, correr no vscode
pip install pandas openpyxl